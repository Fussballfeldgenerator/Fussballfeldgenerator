<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Franks Fußballfeld-Generator</title>

<!-- OpenLayers & proj4 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@9.2.4/ol.css">
<script src="https://cdn.jsdelivr.net/npm/proj4@2.10.0/dist/proj4.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ol@9.2.4/dist/ol.js"></script>

<!-- GeoPackage (clientseitig) -->
<script src="https://unpkg.com/geopackage@3.4.0/dist/geopackage.min.js"></script>

<style>
  html,body,#map{height:100%;margin:0}
  .ctrl{
    position:fixed;top:8px;left:50%;transform:translateX(-50%);
    background:#fff;padding:.35rem .45rem;border-radius:.5rem;
    box-shadow:0 2px 10px rgba(0,0,0,.16);z-index:1000;
    display:flex;gap:.35rem;align-items:center;flex-wrap:wrap;font-size:.84rem
  }
  button,select,input,label{
    padding:.28rem .42rem;border:1px solid #d1d5db;border-radius:.4rem;background:#fff;cursor:pointer;
    font-size:.84rem;line-height:1.1
  }
  label{display:flex;gap:.35rem;align-items:center;border:none;padding:0;background:transparent}
  .primary{background:#0ea5e9;border-color:#0284c7;color:#fff}
  .hint{
    position:fixed;bottom:8px;left:50%;transform:translateX(-50%);
    background:#111827;color:#fff;padding:.28rem .45rem;border-radius:.4rem;z-index:1000;font-size:.8rem;opacity:.9
  }
  input[type=number]{width:5.8rem}
  input[type=text]{width:13rem}
  .disabled-note{font-size:.78rem;opacity:.8;margin-left:.25rem}
  .scenario-note{font-size:.78rem;opacity:.85}
  .warn{color:#b45309;background:#fff7ed;border:1px solid #fed7aa;padding:.25rem .4rem;border-radius:.35rem}
  .muted{font-size:.78rem;opacity:.8}
  @media (max-width:480px){ .ctrl{font-size:.8rem} button,select,input{font-size:.8rem} input[type=text]{width:11rem} }
</style>
</head>
<body>
<div id="map"></div>

<div class="ctrl">
  <button id="loc" class="primary">Standort</button>
  <button id="toggleDOP">Orthofoto</button>

  <select id="mode" title="Modus">
    <option value="grossfeld" selected>Großfeld</option>
    <option value="verkleinertes_grossfeld">verkleinertes Großfeld</option>
    <option value="kleinfeld">Kleinfeld (separat)</option>
  </select>

  <select id="kfScenario" title="Kleinfeld-Szenario" disabled>
    <option value="">Szenario wählen…</option>
    <option value="g2v2_16x20">G-Jugend 2v2 – 16×20 m (Mittellinie, 4 Minitore)</option>
    <option value="g3v3_25x20">G-Jugend 3v3 – 25×20 m (6 m-Zonen, 4 Minitore)</option>
    <option value="f3v3_25x20">F-Jugend 3v3 – 25×20 m (6 m-Zonen, 4 Minitore)</option>
    <option value="f5v5_40x25_mini">F-Jugend 5v5 – 40×25 m (4 Minitore, 6 m-Zonen)</option>
    <option value="f5v5_40x25_kf">F-Jugend 5v5 – 40×25 m (2 Kleinfeldtore, Mittellinie)</option>
    <option value="e5v5_40x25_mini">E-Jugend 5v5 – 40×25 m (4 Minitore, 6 m-Zonen)</option>
    <option value="e5v5_40x25_kf">E-Jugend 5v5 – 40×25 m (2 Kleinfeldtore, Mittellinie)</option>
    <option value="e7v7_55x35">E-Jugend 7v7 – 55×35 m (Mittellinie & Strafraum)</option>
  </select>
  <span id="kfInfo" class="scenario-note" style="display:none;"></span>

  <label>L (m):
    <input id="length" type="number" step="1" min="90" max="120" placeholder="90–120" value="105">
  </label>
  <label>B (m):
    <input id="width"  type="number" step="0.1" min="45" max="90"  placeholder="45–90" value="65">
    <span id="presetNote" class="disabled-note" style="display:none;">(vorgegeben durch Szenario)</span>
  </label>

  <label id="dockWrap" style="display:none;">
    <input type="checkbox" id="dockOption"> vGF andocken
  </label>
  <span id="dockLen" class="muted" style="display:none;"></span>
  <span id="dockWarn" class="warn" style="display:none;"></span>

  <label>Dateiname:
    <input id="fname" type="text" value="Dateiname">
    <span class="muted">.gpkg / .geojson</span>
  </label>

  <button id="reset">Neu</button>
  <button id="exportGPKG">Export GPKG</button>
  <button id="exportGeoJSON">Export GeoJSON</button>
</div>

<div class="hint">Zwei Punkte der rechten Längsseite: 1 = Start (unten rechts), 2 = Richtung (oben rechts).</div>

<script>
/* ========= PROJEKTION (EPSG:25832) ========= */
proj4.defs("EPSG:25832","+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs");
ol.proj.proj4.register(proj4);
const PROJ = ol.proj.get('EPSG:25832');

/* ========= WMTS LAYER (LDBV) ========= */
const CAP_URL = 'https://geoservices.bayern.de/od/wmts/geobasis/v1/1.0.0/WMTSCapabilities.xml';
const wmtsParser = new ol.format.WMTSCapabilities();

let webkarteLayer=null, dop20Layer=null;

const vectorSource = new ol.source.Vector({wrapX:false});
const vectorLayer  = new ol.layer.Vector({
  source:vectorSource,
  style:new ol.style.Style({
    stroke:new ol.style.Stroke({color:'#111',width:2}),
    image:new ol.style.Circle({radius:4,fill:new ol.style.Fill({color:'#111'})})
  })
});

const map = new ol.Map({
  target:'map',
  layers:[vectorLayer],
  view: new ol.View({
    projection: PROJ,
    center: ol.proj.fromLonLat([11.5756,48.1372], PROJ),
    zoom: 18,
    maxZoom: 22
  }),
  controls: ol.control.defaults.defaults()
});

function addWMTSFromCaps(layerName, caps){
  const opt = ol.source.WMTS.optionsFromCapabilities(caps, {
    layer: layerName,
    matrixSet: 'EPSG:25832',
    projection: PROJ
  });
  return new ol.layer.Tile({source:new ol.source.WMTS(opt)});
}

fetch(CAP_URL).then(r=>r.text()).then(txt=>{
  const caps = wmtsParser.read(txt);

  const pick = (names)=> names.find(n => caps.Contents.Layer.some(L=>L.Identifier===n));
  const nameWeb = pick(['WEBATLAS','webatlasde','WebAtlasDE','by_webkarte','webkarte']) || caps.Contents.Layer[0]?.Identifier;
  const nameDOP = pick(['DOP20_RGB','DOP20','by_dop20c']) || caps.Contents.Layer[1]?.Identifier;

  try{
    webkarteLayer = addWMTSFromCaps(nameWeb, caps);
    map.getLayers().insertAt(0, webkarteLayer);
  }catch(e){ console.warn('Webkarte WMTS fehlgeschlagen', e); }

  try{
    dop20Layer = addWMTSFromCaps(nameDOP, caps);
    dop20Layer.setOpacity(0.95);
    dop20Layer.setVisible(false);
    map.getLayers().insertAt(0, dop20Layer);
  }catch(e){ console.warn('DOP20 WMTS fehlgeschlagen', e); }

}).catch(e=>{
  console.warn('Capabilities laden fehlgeschlagen:', e);
  alert('WMTS konnte nicht geladen werden. Arbeiten vorübergehend ohne Hintergrund.');
});

/* Orthofoto Schalter */
document.getElementById('toggleDOP').onclick=()=>{
  if(!dop20Layer){ alert('Orthofoto noch nicht verfügbar.'); return; }
  const vis = !dop20Layer.getVisible();
  dop20Layer.setVisible(vis);
  document.getElementById('toggleDOP').textContent = vis?'Orthofoto aus':'Orthofoto';
};

/* ========= GPS ========= */
let gpsPointFeature=null, gpsCircleFeature=null;
document.getElementById('loc').onclick=()=>{
  if(!navigator.geolocation){ alert('Geolocation nicht verfügbar.'); return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const c = ol.proj.fromLonLat([pos.coords.longitude,pos.coords.latitude], PROJ);
    const acc = Math.max(pos.coords.accuracy||5,3);
    map.getView().animate({center:c, zoom: Math.min(Math.max(18, map.getView().getZoom()), 20), duration:400});
    if(!gpsPointFeature){
      gpsPointFeature = new ol.Feature(new ol.geom.Point(c));
      gpsPointFeature.setStyle(new ol.style.Style({
        image: new ol.style.Circle({radius:5, fill:new ol.style.Fill({color:'#2563eb'}), stroke:new ol.style.Stroke({color:'#1e40af',width:1})})
      }));
      gpsCircleFeature = new ol.Feature(new ol.geom.Circle(c, acc));
      gpsCircleFeature.setStyle(new ol.style.Style({
        stroke:new ol.style.Stroke({color:'#2563eb', width:1, lineDash:[4,4]}),
        fill: new ol.style.Fill({color:'rgba(59,130,246,0.06)'})
      }));
      vectorSource.addFeatures([gpsCircleFeature,gpsPointFeature]);
    }else{
      gpsPointFeature.getGeometry().setCoordinates(c);
      gpsCircleFeature.getGeometry().setCenter(c);
      gpsCircleFeature.getGeometry().setRadius(acc);
    }
  }, ()=>alert('Standort nicht möglich. Bitte HTTPS + Erlaubnis prüfen.'));
};

/* ========= UI ========= */
const el = (id)=>document.getElementById(id);
const modeSel=el('mode'), kfScenario=el('kfScenario'), kfInfo=el('kfInfo'),
      lengthInput=el('length'), widthInput=el('width'),
      dockWrap=el('dockWrap'), dockOption=el('dockOption'),
      dockLen=el('dockLen'), dockWarn=el('dockWarn'),
      fnameInput=el('fname');

const scenarioDims={
  g2v2_16x20:{L:16,W:20,info:"Mittellinie, 4 Minitore"},
  g3v3_25x20:{L:25,W:20,info:"6 m-Schusszonen, 4 Minitore"},
  f3v3_25x20:{L:25,W:20,info:"6 m-Schusszonen, 4 Minitore"},
  f5v5_40x25_mini:{L:40,W:25,info:"6 m-Schusszonen, 4 Minitore"},
  f5v5_40x25_kf:{L:40,W:25,info:"2 Kleinfeldtore, Mittellinie"},
  e5v5_40x25_mini:{L:40,W:25,info:"6 m-Schusszonen, 4 Minitore"},
  e5v5_40x25_kf:{L:40,W:25,info:"2 Kleinfeldtore, Mittellinie"},
  e7v7_55x35:{L:55,W:35,info:"Mittellinie, 5-m-Tore + Strafraum"}
};
const getScenario=()=>scenarioDims[kfScenario.value]||null;

function updateScenarioInfo(){
  if(modeSel.value!=='kleinfeld'){ kfInfo.style.display='none'; return; }
  const d=getScenario();
  if(d){ kfInfo.textContent=`(L=${d.L} m, B=${d.W} m — ${d.info})`; kfInfo.style.display='inline'; lengthInput.value=d.L; widthInput.value=d.W; }
  else{ kfInfo.textContent=''; kfInfo.style.display='none'; }
}
function updateDockAvailability(){
  const isV=(modeSel.value==='verkleinertes_grossfeld');
  dockWrap.style.display=isV?'inline-flex':'none';
  dockLen.style.display=isV?'inline':'none';
  dockWarn.style.display='none';
  if(!isV) return;
  const L = Number(lengthInput.value)||105;
  const std = L - 33;
  const dc  = L - 16.5;
  dockLen.textContent=`vGF Länge: Standard ${Math.round(std)} m | Andocken ${dc.toFixed(1)} m`;
  if(L<103){
    dockWarn.style.display='inline';
    dockWarn.textContent = std<70
      ? `Hinweis: Standard vGF = ${Math.round(std)} m (<70 m). Andocken = ${dc.toFixed(1)} m.`
      : `Option verfügbar: Standard ${Math.round(std)} m, Andocken ${dc.toFixed(1)} m.`;
  }
}
function updateInputLocking(){
  const isKF=(modeSel.value==='kleinfeld');
  kfScenario.disabled=!isKF;
  lengthInput.disabled=isKF;
  widthInput.disabled=isKF;
  el('presetNote').style.display=isKF?'inline':'none';
  updateScenarioInfo();
  updateDockAvailability();
}
modeSel.addEventListener('change',()=>{ updateInputLocking(); if(p1&&p2) redraw(); });
kfScenario.addEventListener('change',()=>{ updateScenarioInfo(); if(p1&&p2) redraw(); });
lengthInput.addEventListener('change',()=>{ updateDockAvailability(); if(p1&&p2) redraw(); });
widthInput.addEventListener('change',()=>{ if(p1&&p2) redraw(); });

/* ========= Klick-Logik (2 Punkte) ========= */
let p1=null, p2=null; // EPSG:25832-Koordinaten
const clickOverlaySrc = new ol.source.Vector();
const clickOverlay = new ol.layer.Vector({source:clickOverlaySrc, style: new ol.style.Style({
  image: new ol.style.Circle({radius:5, fill:new ol.style.Fill({color:'#ef4444'})})
})});
map.addLayer(clickOverlay);

map.on('click',evt=>{
  if(!p1){
    p1 = evt.coordinate;
    clickOverlaySrc.addFeature(new ol.Feature(new ol.geom.Point(p1)));
  } else if(!p2){
    p2 = evt.coordinate;
    clickOverlaySrc.addFeature(new ol.Feature(new ol.geom.Point(p2)));
    redraw();
  }
});
document.getElementById('reset').onclick=()=>{
  p1=p2=null;
  vectorSource.clear();
  clickOverlaySrc.clear();
  gpsPointFeature=null; gpsCircleFeature=null;
  lastResult=null;
};

/* ========= Geometrie-Helpers ========= */
const norm=(dx,dy)=>{const L=Math.hypot(dx,dy)||1;return{ux:dx/L,uy:dy/L,L}};
const mid =(A,B)=>({x:(A.x+B.x)/2,y:(A.y+B.y)/2});
function addLine(a,b,name,out){
  const feat=new ol.Feature(new ol.geom.LineString([ [a.x,a.y],[b.x,b.y] ]));
  feat.set('name',name); vectorSource.addFeature(feat);
  out.lines.push({name,p1:a,p2:b});
}
function addPt(p,name,out){
  const feat=new ol.Feature(new ol.geom.Point([p.x,p.y]));
  feat.set('name',name); vectorSource.addFeature(feat);
  out.points.push({name,x:p.x,y:p.y});
}
function addPoly(points,name,out){
  const coords=points.map(p=>[p.x,p.y]);
  const feat=new ol.Feature(new ol.geom.LineString(coords));
  feat.set('name',name); vectorSource.addFeature(feat);
  out.lines.push({name,points});
}
function circlePts(c,r,seg=96){
  const pts=[]; for(let i=0;i<=seg;i++){ const a=2*Math.PI*i/seg; pts.push({x:c.x+r*Math.cos(a),y:c.y+r*Math.sin(a)}); }
  return pts;
}
function lineIntersect(a1,a2,b1,b2){
  const x1=a1.x,y1=a1.y,x2=a2.x,y2=a2.y,x3=b1.x,y3=b1.y,x4=b2.x,y4=b2.y;
  const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if(Math.abs(den)<1e-9)return null;
  const px=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/den;
  const py=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/den;
  return {x:px,y:py};
}

/* ========= Feld-Zeichenfunktionen ========= */
function drawTorbereich(mitte,ux,uy,nx,ny,prefix,out){
  const torHalb=7.32/2;
  const tor_r={x:mitte.x+nx*torHalb,y:mitte.y+ny*torHalb};
  const tor_l={x:mitte.x-nx*torHalb,y:mitte.y-ny*torHalb};
  addPt(mitte,`Torlinienmittelpunkt ${prefix}`,out);
  addPt(tor_r,`Torpfosten ${prefix} rechts`,out);
  addPt(tor_l,`Torpfosten ${prefix} links`,out);
  addLine(tor_r,tor_l,`Torlinie ${prefix}`,out);

  const f5r={x:tor_r.x+nx*5.5,y:tor_r.y+ny*5.5};
  const f5l={x:tor_l.x-nx*5.5,y:tor_l.y-ny*5.5};
  addPt(f5r,`5m Fusspunkt ${prefix} rechts`,out);
  addPt(f5l,`5m Fusspunkt ${prefix} links`,out);
  const e5r={x:f5r.x+ux*5.5,y:f5r.y+uy*5.5};
  const e5l={x:f5l.x+ux*5.5,y:f5l.y+uy*5.5};
  addLine(f5r,e5r,`5m Linie ${prefix} rechts`,out);
  addLine(f5l,e5l,`5m Linie ${prefix} links`,out);
  addLine(e5r,e5l,`5m Parallel ${prefix}`,out);
  addPt(e5r,`5m Eckpunkt ${prefix} rechts`,out);
  addPt(e5l,`5m Eckpunkt ${prefix} links`,out);

  const f16r={x:tor_r.x+nx*16.5,y:tor_r.y+ny*16.5};
  const f16l={x:tor_l.x-nx*16.5,y:tor_l.y-ny*16.5};
  addPt(f16r,`16,5m Fusspunkt ${prefix} rechts`,out);
  addPt(f16l,`16,5m Fusspunkt ${prefix} links`,out);
  const e16r={x:f16r.x+ux*16.5,y:f16r.y+uy*16.5};
  const e16l={x:f16l.x+ux*16.5,y:f16l.y+uy*16.5};
  addPt(e16r,`16,5m Eckpunkt ${prefix} rechts`,out);
  addPt(e16l,`16,5m Eckpunkt ${prefix} links`,out);
  addLine(f16r,e16r,`16,5m Linie ${prefix} rechts`,out);
  addLine(f16l,e16l,`16,5m Linie ${prefix} links`,out);
  addLine(e16r,e16l,`16,5m Parallel ${prefix}`,out);

  const elfer={x:mitte.x+ux*11,y:mitte.y+uy*11};
  addPt(elfer,`Elfmeterpunkt ${prefix}`,out);
}
function drawMiniGoalsOnEnd(endLeft, endRight, namePrefix, out){
  const ex=endRight.x-endLeft.x, ey=endRight.y-endLeft.y;
  const el=Math.hypot(ex,ey)||1, vx=ex/el, vy=ey/el;
  const L1={x:endLeft.x+vx*2,y:endLeft.y+vy*2};
  const L2={x:L1.x+vx*2,y:L1.y+vy*2};
  addPt(L1,`${namePrefix} Minitor-Pfosten links`,out);
  addLine(L1,L2,`${namePrefix} Minitor links (2 m)`,out);
  const R1={x:endRight.x-vx*2,y:endRight.y-vy*2};
  const R2={x:R1.x-vx*2,y:R1.y-vy*2};
  addPt(R1,`${namePrefix} Minitor-Pfosten rechts`,out);
  addLine(R1,R2,`${namePrefix} Minitor rechts (2 m)`,out);
}
function drawKleinfeldGoalOnEnd(endLeft, endRight, namePrefix, out){
  const ex=endRight.x-endLeft.x, ey=endRight.y-endLeft.y;
  const el=Math.hypot(ex,ey)||1, vx=ex/el, vy=ey/el;
  const mid={x:(endLeft.x+endRight.x)/2, y:(endLeft.y+endRight.y)/2};
  addPt(mid,`${namePrefix} Tor-Mittelpunkt`,out);
  const pR={x:mid.x+vx*2.5, y:mid.y+vy*2.5};
  const pL={x:mid.x-vx*2.5, y:mid.y-vy*2.5};
  addPt(pR,`${namePrefix} Torpfosten rechts (±2.5m)`,out);
  addPt(pL,`${namePrefix} Torpfosten links (±2.5m)`,out);
  addLine(pL,pR,`${namePrefix} Torlinie (5 m)`,out);
}
function markE7v7End(endLeft, endRight, intoFieldDir, namePrefix, out){
  const ex=endRight.x-endLeft.x, ey=endRight.y-endLeft.y;
  const el=Math.hypot(ex,ey)||1, vx=ex/el, vy=ey/el;
  const mid={x:(endLeft.x+endRight.x)/2, y:(endLeft.y+endRight.y)/2};
  addPt(mid,`${namePrefix} Tor-Mittelpunkt`,out);
  const pR={x:mid.x+vx*2.5, y:mid.y+vy*2.5};
  const pL={x:mid.x-vx*2.5, y:mid.y-vy*2.5};
  addPt(pR,`${namePrefix} Torpfosten rechts (±2.5m)`,out);
  addPt(pL,`${namePrefix} Torpfosten links (±2.5m)`,out);
  addLine(pL,pR,`${namePrefix} Torlinie (5 m)`,out);
  const fL={x:pL.x - vx*12, y:pL.y - vy*12};
  const fR={x:pR.x + vx*12, y:pR.y + vy*12};
  addPt(fL,`${namePrefix} Fusspunkt Strafraum links (+12m)`,out);
  addPt(fR,`${namePrefix} Fusspunkt Strafraum rechts (+12m)`,out);
  const ix=intoFieldDir.x, iy=intoFieldDir.y;
  const cL={x:fL.x + ix*12, y:fL.y + iy*12};
  const cR={x:fR.x + ix*12, y:fR.y + iy*12};
  addPt(cL,`${namePrefix} Ecke Strafraum links (12m orth.)`,out);
  addPt(cR,`${namePrefix} Ecke Strafraum rechts (12m orth.)`,out);
  addLine(fL, cL, `${namePrefix} Strafraum Linie links`, out);
  addLine(fR, cR, `${namePrefix} Strafraum Linie rechts`, out);
  addLine(cL, cR, `${namePrefix} Strafraum Vorderkante`, out);
  const sp={x:mid.x + ix*8, y:mid.y + iy*8};
  addPt(sp,`${namePrefix} Strafstoßpunkt (8 m)`,out);
}
function drawSchusszonen(UL,UR,OL,OR, ux,uy, namePrefix, out){
  const bottomA={x:UL.x+ux*6, y:UL.y+uy*6};
  const bottomB={x:UR.x+ux*6, y:UR.y+uy*6};
  const topA   ={x:OL.x-ux*6, y:OL.y-uy*6};
  const topB   ={x:OR.x-ux*6, y:OR.y-uy*6};
  addLine(bottomA,bottomB,`${namePrefix} Schusszone unten (6 m)`,out);
  addLine(topA,topB,      `${namePrefix} Schusszone oben (6 m)`,out);
  return {bottomA,bottomB,topA,topB};
}
function drawReducedField(UL,UR,OL,OR, ux,uy,nx,ny, dock, out){
  let bL,bR,tL,tR;
  if(dock){ bL={x:UL.x,y:UL.y}; bR={x:UR.x,y:UR.y};
            tL={x:OL.x-ux*16.5,y:OL.y-uy*16.5}; tR={x:OR.x-ux*16.5,y:OR.y-uy*16.5};
  } else {  bL={x:UL.x+ux*16.5,y:UL.y+uy*16.5}; bR={x:UR.x+ux*16.5,y:UR.y+uy*16.5};
            tL={x:OL.x-ux*16.5,y:OL.y-uy*16.5}; tR={x:OR.x-ux*16.5,y:OR.y-uy*16.5};
  }
  addLine(bL,bR,"(vGF) Torlinie unten",out);
  addLine(tL,tR,"(vGF) Torlinie oben",out);

  const mB={x:(bL.x+bR.x)/2,y:(bL.y+bR.y)/2};
  const mT={x:(tL.x+tR.x)/2,y:(tL.y+tR.y)/2};
  addPt(mB,"(vGF) Tor-Mittelpunkt unten",out);
  addPt(mT,"(vGF) Tor-Mittelpunkt oben",out);

  const pBR={x:mB.x+nx*2.5,y:mB.y+ny*2.5};
  const pBL={x:mB.x-nx*2.5,y:mB.y-ny*2.5};
  const pTR={x:mT.x+nx*2.5,y:mT.y+ny*2.5};
  const pTL={x:mT.x-nx*2.5,y:mT.y-ny*2.5};
  addPt(pBR,"(vGF) Pfosten unten rechts",out);
  addPt(pBL,"(vGF) Pfosten unten links",out);
  addPt(pTR,"(vGF) Pfosten oben rechts",out);
  addPt(pTL,"(vGF) Pfosten oben links",out);
  addLine(pBL,pBR,"(vGF) Torlinie unten (5 m)",out);
  addLine(pTL,pTR,"(vGF) Torlinie oben (5 m)",out);

  const sFB_R={x:mB.x+nx*14.5,y:mB.y+ny*14.5};
  const sFB_L={x:mB.x-nx*14.5,y:mB.y-ny*14.5};
  const sFT_R={x:mT.x+nx*14.5,y:mT.y+ny*14.5};
  const sFT_L={x:mT.x-nx*14.5,y:mT.y-ny*14.5};
  addPt(sFB_R,"(vGF) Strafraum-Fusspunkt unten rechts",out);
  addPt(sFB_L,"(vGF) Strafraum-Fusspunkt unten links",out);
  addPt(sFT_R,"(vGF) Strafraum-Fusspunkt oben rechts",out);
  addPt(sFT_L,"(vGF) Strafraum-Fusspunkt oben links",out);

  const cB_R={x:sFB_R.x+ux*12,y:sFB_R.y+uy*12};
  const cB_L={x:sFB_L.x+ux*12,y:sFB_L.y+uy*12};
  const cT_R={x:sFT_R.x-ux*12,y:sFT_R.y-uy*12};
  const cT_L={x:sFT_L.x-ux*12,y:sFT_L.y-uy*12};
  addPt(cB_R,"(vGF) Strafraum-Ecke unten rechts",out);
  addPt(cB_L,"(vGF) Strafraum-Ecke unten links",out);
  addPt(cT_R,"(vGF) Strafraum-Ecke oben rechts",out);
  addPt(cT_L,"(vGF) Strafraum-Ecke oben links",out);
  addLine(sFB_R,cB_R,"(vGF) Strafraum Linie unten rechts",out);
  addLine(sFB_L,cB_L,"(vGF) Strafraum Linie unten links",out);
  addLine(sFT_R,cT_R,"(vGF) Strafraum Linie oben rechts",out);
  addLine(sFT_L,cT_L,"(vGF) Strafraum Linie oben links",out);
  addLine(cB_L,cB_R,"(vGF) Strafraum-Front unten",out);
  addLine(cT_L,cT_R,"(vGF) Strafraum-Front oben",out);

  const sB_R={x:mB.x+nx*24.5,y:mB.y+ny*24.5};
  const sB_L={x:mB.x-nx*24.5,y:mB.y-ny*24.5};
  const sT_R={x:mT.x+nx*24.5,y:mT.y+ny*24.5};
  const sT_L={x:mT.x-nx*24.5,y:mT.y-ny*24.5};
  addLine(sB_L,sT_L,"(vGF) Seitenlinie links",out);
  addLine(sB_R,sT_R,"(vGF) Seitenlinie rechts",out);

  addPt(sB_L,"(vGF) Spielfeldecke unten links",out);
  addPt(sB_R,"(vGF) Spielfeldecke unten rechts",out);
  addPt(sT_L,"(vGF) Spielfeldecke oben links",out);
  addPt(sT_R,"(vGF) Spielfeldecke oben rechts",out);

  const midLeft={x:(sB_L.x+sT_L.x)/2,y:(sB_L.y+sT_L.y)/2};
  const midRight={x:(sB_R.x+sT_R.x)/2,y:(sB_R.y+sT_R.y)/2};
  addLine(midLeft,midRight,"(vGF) Mittellinie",out);
  const kickoff={x:(midLeft.x+midRight.x)/2,y:(midLeft.y+midRight.y)/2};
  addPt(kickoff,"(vGF) Anstoßpunkt",out);
  addPt(midLeft,"(vGF) Schnittpunkt Mittellinie & Seitenlinie links",out);
  addPt(midRight,"(vGF) Schnittpunkt Mittellinie & Seitenlinie rechts",out);

  const penB={x:mB.x+ux*9,y:mB.y+uy*9};
  const penT={x:mT.x-ux*9,y:mT.y-uy*9};
  addPt(penB,"(vGF) Strafstoßpunkt unten (9 m)",out);
  addPt(penT,"(vGF) Strafstoßpunkt oben (9 m)",out);
}
function drawKleinfeldSeparate(UR,OR,UL,OL, ux,uy,nx,ny,out){
  const s=kfScenario.value;
  addLine(UL,UR,"(KF) Grundlinie unten",out);
  addLine(UR,OR,"(KF) Seitenlinie rechts",out);
  addLine(OR,OL,"(KF) Grundlinie oben",out);
  addLine(OL,UL,"(KF) Seitenlinie links",out);
  addPt(UL,"(KF) Eckpunkt unten links",out);
  addPt(UR,"(KF) Eckpunkt unten rechts",out);
  addPt(OL,"(KF) Eckpunkt oben links",out);
  addPt(OR,"(KF) Eckpunkt oben rechts",out);

  const sideRight={A:UR,B:OR}, sideLeft={A:UL,B:OL};

  const ml=mid(UL,OL), mr=mid(UR,OR);
  const midCenter={x:(ml.x+mr.x)/2, y:(ml.y+mr.y)/2};
  const needMid=(s==='g2v2_16x20'||s==='e5v5_40x25_kf'||s==='f5v5_40x25_kf'||s==='e7v7_55x35');
  if(needMid){
    addLine(ml,mr,"(KF) Mittellinie",out);
    addPt(midCenter,"(KF) Mittellinie Mittelpunkt",out);
    const spR=lineIntersect(sideRight.A,sideRight.B,ml,mr);
    const spL=lineIntersect(sideLeft.A,sideLeft.B,ml,mr);
    if(spR) addPt(spR,"(KF) Schnittpunkt Mittellinie & Seitenlinie rechts",out);
    if(spL) addPt(spL,"(KF) Schnittpunkt Mittellinie & Seitenlinie links",out);
  }

  const needZones=(s==='g3v3_25x20'||s==='f3v3_25x20'||s==='e5v5_40x25_mini'||s==='f5v5_40x25_mini');
  if(needZones){
    const z=drawSchusszonen(UL,UR,OL,OR,ux,uy,"(KF)",out);
    const izR=lineIntersect(sideRight.A,sideRight.B,z.bottomA,z.bottomB);
    const izL=lineIntersect(sideLeft.A, sideLeft.B ,z.bottomA,z.bottomB);
    const ozR=lineIntersect(sideRight.A,sideRight.B,z.topA   ,z.topB   );
    const ozL=lineIntersect(sideLeft.A ,sideLeft.B ,z.topA   ,z.topB   );
    if(izR) addPt(izR,"(KF) Schnittpunkt rechts & Schusszone unten",out);
    if(izL) addPt(izL,"(KF) Schnittpunkt links  & Schusszone unten",out);
    if(ozR) addPt(ozR,"(KF) Schnittpunkt rechts & Schusszone oben",out);
    if(ozL) addPt(ozL,"(KF) Schnittpunkt links  & Schusszone oben",out);
  }

  if(s==='g2v2_16x20'||s==='g3v3_25x20'||s==='f3v3_25x20'||s==='e5v5_40x25_mini'||s==='f5v5_40x25_mini'){
    drawMiniGoalsOnEnd(UL,UR,"(KF) unten",out);
    drawMiniGoalsOnEnd(OL,OR,"(KF) oben",out);
  } else if(s==='e5v5_40x25_kf'||s==='f5v5_40x25_kf'){
    drawKleinfeldGoalOnEnd(UL,UR,"(KF) unten",out);
    drawKleinfeldGoalOnEnd(OL,OR,"(KF) oben",out);
  } else if(s==='e7v7_55x35'){
    const intoB={x:ux,y:uy}, intoT={x:-ux,y:-uy};
    markE7v7End(UL,UR,intoB,"(KF) unten",out);
    markE7v7End(OL,OR,intoT,"(KF) oben",out);
  }
}

/* ========= Zeichnen ========= */
let lastResult=null;

function redraw(){
  if(!p1||!p2) return;
  vectorSource.getFeatures().forEach(f=>{
    const n=f.get('name'); if(n) vectorSource.removeFeature(f);
  });

  const P1={x:p1[0],y:p1[1]}, P2={x:p2[0],y:p2[1]};
  const {ux,uy}=norm(P2.x-P1.x,P2.y-P1.y);
  const nx=-uy, ny=ux;

  let len,W; const mode=modeSel.value;
  if(mode==='kleinfeld'){
    const d=getScenario(); if(!d){ alert('Bitte ein Kleinfeld-Szenario wählen.'); return; }
    len=d.L; W=d.W;
  }else{
    const Lval=parseInt(lengthInput.value,10);
    const Wval=Number(widthInput.value.replace(',','.'));
    if(!(Lval>=90&&Lval<=120)) return;
    if(!(Wval>=45&&Wval<=90))  return;
    len=Lval; W=Wval;
  }

  const UR={x:P1.x,y:P1.y};
  const OR={x:P1.x+ux*len,y:P1.y+uy*len};
  const OL={x:OR.x+nx*W,y:OR.y+ny*W};
  const UL={x:UR.x+nx*W,y:UR.y+ny*W};

  const out={points:[],lines:[]};

  if(mode==='kleinfeld'){
    drawKleinfeldSeparate(UR,OR,UL,OL,ux,uy,nx,ny,out);
    lastResult=out; return;
  }

  // Großfeld außen + Mittellinie/Mittelkreis
  addLine(UL,UR,"Grundlinie unten",out);
  addLine(UR,OR,"Seitenlinie rechts",out);
  addLine(OR,OL,"Grundlinie oben",out);
  addLine(OL,UL,"Seitenlinie links",out);
  addPt(UL,"Eckfahne unten links",out);
  addPt(UR,"Eckfahne unten rechts",out);
  addPt(OL,"Eckfahne oben links",out);
  addPt(OR,"Eckfahne oben rechts",out);

  const mu=mid(UL,UR), mo=mid(OL,OR);
  const mlGF=mid(UL,OL), mrGF=mid(UR,OR);
  addLine(mlGF,mrGF,"Mittellinie",out);
  const midCenterGF={x:(mlGF.x+mrGF.x)/2, y:(mlGF.y+mrGF.y)/2};
  addPt(midCenterGF,"Mittellinie Mittelpunkt",out);
  const center={x:(mu.x+mo.x)/2,y:(mu.y+mo.y)/2};
  addPoly(circlePts(center,9.15,96),"Mittelkreis",out);

  const spR=lineIntersect(UR,OR,mlGF,mrGF);
  const spL=lineIntersect(UL,OL,mlGF,mrGF);
  if(spR) addPt(spR,"Schnittpunkt Mittellinie & Seitenlinie rechts",out);
  if(spL) addPt(spL,"Schnittpunkt Mittellinie & Seitenlinie links",out);

  drawTorbereich(mu,ux,uy,nx,ny,"unten",out);
  drawTorbereich(mo,-ux,-uy,nx,ny,"oben",out);

  if(mode==='verkleinertes_grossfeld'){
    const dock=!!dockOption.checked;
    drawReducedField(UL,UR,OL,OR,ux,uy,nx,ny,dock,out);
  }

  lastResult=out;
}

/* ========= Export ========= */
// 1) GeoJSON: beide CRS-Varianten (WGS84 für SW Maps, UTM32 für QGIS)
document.getElementById('exportGeoJSON').onclick=()=>{
  if(!lastResult){ alert('Kein Feld erzeugt.'); return; }

  const base=(fnameInput.value||'Dateiname').replace(/[\\/:*?"<>|]+/g,'_');
  const ts=new Date().toISOString().replace(/[:.]/g,'-');

  const makeFC = (crsName)=>({type:'FeatureCollection', crs:{type:'name',properties:{name:crsName}}, features:[]});
  const to4326 = (x,y)=> ol.proj.transform([x,y], PROJ, 'EPSG:4326'); // [lon,lat]
  const save = (obj,fn)=>{ const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/geo+json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=fn; a.click(); URL.revokeObjectURL(a.href); };

  // UTM32N
  const pts_utm = makeFC('EPSG:25832');
  for(const p of lastResult.points){
    pts_utm.features.push({type:'Feature',properties:{name:p.name},geometry:{type:'Point',coordinates:[p.x,p.y]}});
  }
  const lines_utm = makeFC('EPSG:25832');
  for(const l of lastResult.lines){
    const coords = l.points ? l.points.map(q=>[q.x,q.y]) : [[l.p1.x,l.p1.y],[l.p2.x,l.p2.y]];
    lines_utm.features.push({type:'Feature',properties:{name:l.name},geometry:{type:'LineString',coordinates:coords}});
  }

  // WGS84
  const pts_wgs = makeFC('EPSG:4326');
  for(const p of lastResult.points){
    const [lon,lat] = to4326(p.x,p.y);
    pts_wgs.features.push({type:'Feature',properties:{name:p.name},geometry:{type:'Point',coordinates:[lon,lat]}});
  }
  const lines_wgs = makeFC('EPSG:4326');
  for(const l of lastResult.lines){
    const src = l.points ? l.points.map(q=>[q.x,q.y]) : [[l.p1.x,l.p1.y],[l.p2.x,l.p2.y]];
    const coords = src.map(([x,y])=> to4326(x,y));
    lines_wgs.features.push({type:'Feature',properties:{name:l.name},geometry:{type:'LineString',coordinates:coords}});
  }

  save(pts_wgs,  `${base}_wgs84_points_${ts}.geojson`);
  save(lines_wgs,`${base}_wgs84_lines_${ts}.geojson`);
  save(pts_utm,  `${base}_utm32_points_${ts}.geojson`);
  save(lines_utm,`${base}_utm32_lines_${ts}.geojson`);
};

// 2) GeoPackage: beide Layer in 1 Datei (EPSG:25832)
document.getElementById('exportGPKG').onclick=async()=>{
  if(!lastResult){ alert('Kein Feld erzeugt.'); return; }
  if(!window.GeoPackage){ alert('GPKG-Bibliothek nicht verfügbar.'); return; }

  try{
    // Neues leeres GeoPackage im Speicher
    const gp = await GeoPackage.create();

    // Feature-Tabellen anlegen
    await gp.createFeatureTable('punkte', {
      geometryColumn: 'geom',
      geometryType: 'POINT',
      srsId: 25832,
      properties: { name: 'TEXT' }
    });
    await gp.createFeatureTable('linien', {
      geometryColumn: 'geom',
      geometryType: 'LINESTRING',
      srsId: 25832,
      properties: { name: 'TEXT' }
    });

    // Punkte einfügen
    for(const p of lastResult.points){
      await gp.insertFeature('punkte', {
        geom: { type:'Point', coordinates:[p.x,p.y] },
        properties: { name: p.name }
      });
    }
    // Linien einfügen
    for(const l of lastResult.lines){
      const coords = l.points ? l.points.map(q=>[q.x,q.y]) : [[l.p1.x,l.p1.y],[l.p2.x,l.p2.y]];
      await gp.insertFeature('linien', {
        geom: { type:'LineString', coordinates: coords },
        properties: { name: l.name }
      });
    }

    // Datei als Blob exportieren
    const blob = await gp.export();
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download=( (document.getElementById('fname').value||'Dateiname').replace(/[\\/:*?"<>|]+/g,'_') + '.gpkg');
    a.click();
    URL.revokeObjectURL(a.href);
  }catch(err){
    console.error('GPKG-Export fehlgeschlagen:', err);
    alert('GPKG-Export nicht möglich (Browser-Einschränkung). Bitte die GeoJSON-Exporte verwenden.');
  }
};

/* ========= Start ========= */
updateInputLocking();
</script>
</body>
</html>