<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Franks Fußballfeld-Generator</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html,body,#map{height:100%;margin:0}
  .ctrl{
    position:fixed;top:8px;left:50%;transform:translateX(-50%);
    background:#fff;padding:.35rem .45rem;border-radius:.5rem;
    box-shadow:0 2px 10px rgba(0,0,0,.16);z-index:1000;
    display:flex;gap:.35rem;align-items:center;flex-wrap:wrap;font-size:.84rem
  }
  button,select,input{
    padding:.28rem .42rem;border:1px solid #d1d5db;border-radius:.4rem;background:#fff;cursor:pointer;
    font-size:.84rem;line-height:1.1
  }
  .primary{background:#0ea5e9;border-color:#0284c7;color:#fff}
  .hint{
    position:fixed;bottom:8px;left:50%;transform:translateX(-50%);
    background:#111827;color:#fff;padding:.28rem .45rem;border-radius:.4rem;z-index:1000;font-size:.8rem;opacity:.9
  }
  label{display:flex;gap:.35rem;align-items:center}
  input[type=number]{width:5.8rem}
  input[type=text]{width:13rem}
  @media (max-width:480px){ .ctrl{font-size:.8rem} button,select,input{font-size:.8rem} input[type=text]{width:11rem} }
</style>
</head>
<body>
<div id="map"></div>

<div class="ctrl">
  <button id="loc" class="primary">Standort</button>
  <button id="wms">Orthofoto</button>
  <select id="mode" title="Modus">
    <option value="grossfeld" selected>Großfeld</option>
    <option value="kleinfeld_im_grossfeld">+ Kleinfeld</option>
  </select>
  <label>L (m): <input id="length" type="number" step="1" min="1" value=""></label>
  <label>B (m): <input id="width" type="number" step="0.1" value="65"></label>
  <label>Filename: <input id="fname" type="text" value="X-Platz_SVU"></label>
  <button id="reset">Neu</button>
  <button id="geojson">Export</button>
</div>
<div class="hint">Zwei Punkte der rechten Längsseite: 1 = Start (unten rechts), 2 = Richtung (oben rechts).</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/proj4@2.10.0/dist/proj4.js"></script>
<script>
/* ---- EPSG:25832 ---- */
proj4.defs("EPSG:25832","+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs");
const toUTM=(lat,lon)=>{const r=proj4("WGS84","EPSG:25832",[lon,lat]);return{x:r[0],y:r[1]}};
const toLL =(x,y)=>{const r=proj4("EPSG:25832","WGS84",[x,y]);return{lat:r[1],lon:r[0]}};

/* ---- Karte ---- */
const map=L.map('map').setView([48.1372,11.5756],18);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20,attribution:'© OpenStreetMap-Mitwirkende'}).addTo(map);

let dop=null; // DOP20 WMS (transparent, 1.1.1)
document.getElementById('wms').onclick=()=>{
  const btn=document.getElementById('wms');
  if(dop){map.removeLayer(dop);dop=null;btn.textContent="Orthofoto";return;}
  dop=L.tileLayer.wms('https://geoservices.bayern.de/od/wms/dop/v1/dop20?',{
    layers:'by_dop20c',version:'1.1.1',format:'image/png',transparent:true,uppercase:true,tileSize:256,
    attribution:'© LDBV DOP20 (WMS) CC BY 4.0'
  }).addTo(map);
  let err=0; dop.on('tileerror',()=>{ if(++err===3){ map.removeLayer(dop); dop=null; alert('Orthofoto WMS nicht erreichbar/zu hoher Zoom – bleibe bei OSM.'); btn.textContent="Orthofoto"; }});
  btn.textContent="Orthofoto aus";
};

/* ---- Standort ---- */
document.getElementById('loc').onclick=()=>{
  if(!navigator.geolocation){alert('Geolocation nicht verfügbar');return;}
  navigator.geolocation.getCurrentPosition(pos=>{
    const {latitude,longitude,accuracy}=pos.coords;
    const z=accuracy<10?20:accuracy<25?19:18;
    map.setView([latitude,longitude],z);
    L.circle([latitude,longitude],{radius:accuracy}).addTo(draw);
  },()=>alert('Standort nicht möglich. Bitte HTTPS + Erlaubnis prüfen.'),{enableHighAccuracy:true,timeout:10000,maximumAge:0});
};

/* ---- Zeichenlayer ---- */
const draw=L.featureGroup().addTo(map);
const handles=L.featureGroup().addTo(map);
const clicks=L.featureGroup().addTo(map);
let p1=null,p2=null,lastResult=null;

/* ---- UI-Refs ---- */
const widthInput=document.getElementById('width');
const modeSel=document.getElementById('mode');
const fnameInput=document.getElementById('fname');
const lengthInput=document.getElementById('length');
modeSel.addEventListener('change',()=>{ if(p1&&p2) recompute(true); });
widthInput.addEventListener('input',()=>{ if(p1&&p2) recompute(true); });
lengthInput.addEventListener('input',()=>{ if(p1&&p2) recompute(true); });

/* ---- Helpers ---- */
const norm=(dx,dy)=>{const L=Math.hypot(dx,dy)||1;return{ux:dx/L,uy:dy/L,L}};
const mid =(A,B)=>({x:(A.x+B.x)/2,y:(A.y+B.y)/2});
const toLLArr=ps=>ps.map(p=>{const g=toLL(p.x,p.y);return[g.lat,g.lon]});
function addLine(pA,pB,name,out){const gA=toLL(pA.x,pA.y),gB=toLL(pB.x,pB.y);L.polyline([[gA.lat,gA.lon],[gB.lat,gB.lon]]).addTo(draw).bindTooltip(name);out.lines.push({name,len:Math.hypot(pB.x-pA.x,pB.y-pA.y),p1:pA,p2:pB});}
function addPt(p,name,out){const g=toLL(p.x,p.y);L.circleMarker([g.lat,g.lon],{radius:4}).addTo(draw).bindTooltip(name);out.points.push({name,x:p.x,y:p.y});}
function addPoly(points,name,out){L.polyline(toLLArr(points)).addTo(draw).bindTooltip(name);let len=0;for(let i=1;i<points.length;i++){const a=points[i-1],b=points[i];len+=Math.hypot(b.x-a.x,b.y-a.y);}out.lines.push({name,len,points});}
function circle(c,r,seg=96){const pts=[];for(let i=0;i<=seg;i++){const a=2*Math.PI*i/seg;pts.push({x:c.x+r*Math.cos(a),y:c.y+r*Math.sin(a)});}return pts;}
function lineIntersection(a1,a2,b1,b2){
  const x1=a1.x,y1=a1.y,x2=a2.x,y2=a2.y,x3=b1.x,y3=b1.y,x4=b2.x,y4=b2.y;
  const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if(Math.abs(den)<1e-9)return null;
  const px=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/den;
  const py=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/den;
  return {x:px,y:py};
}
/* Schnittpunkte Kreis (Mittelkreis) mit Linie (Mittellinie) */
function circleLineIntersections(C,R,A,B){
  // Parametrische Linie P(t)=A + t*(B-A)
  const dx=B.x-A.x, dy=B.y-A.y;
  const fx=A.x-C.x, fy=A.y-C.y;
  const a=dx*dx+dy*dy;
  const b=2*(fx*dx+fy*dy);
  const c=fx*fx+fy*fy-R*R;
  const disc=b*b-4*a*c;
  if(disc<0) return [];
  if(Math.abs(disc)<1e-9){ // tangential
    const t=-b/(2*a);
    return [{x:A.x+t*dx, y:A.y+t*dy}];
  }
  const s=Math.sqrt(disc);
  const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a);
  return [
    {x:A.x+t1*dx, y:A.y+t1*dy},
    {x:A.x+t2*dx, y:A.y+t2*dy}
  ];
}

/* ---- Großfeld-Geometrie (Tor 7,32 m) ---- */
function drawTorbereich(mitte,ux,uy,nx,ny,prefix,out){
  const torHalb=7.32/2;
  const tor_r={x:mitte.x+nx*torHalb,y:mitte.y+ny*torHalb};
  const tor_l={x:mitte.x-nx*torHalb,y:mitte.y-ny*torHalb};
  addPt(mitte,`Torlinienmittelpunkt ${prefix}`,out);
  addPt(tor_r,`Torpfosten ${prefix} rechts`,out);
  addPt(tor_l,`Torpfosten ${prefix} links`,out);
  addLine(tor_r,tor_l,`Torlinie ${prefix}`,out);

  // 5-m-Raum
  const f5r={x:tor_r.x+nx*5.5,y:tor_r.y+ny*5.5},
        f5l={x:tor_l.x-nx*5.5,y:tor_l.y-ny*5.5};
  const e5r={x:f5r.x+ux*5.5,y:f5r.y+uy*5.5},
        e5l={x:f5l.x+ux*5.5,y:f5l.y+uy*5.5};
  addPt(f5r,`5m Fusspunkt ${prefix} rechts`,out);
  addPt(f5l,`5m Fusspunkt ${prefix} links`,out);
  addPt(e5r,`5m Ecke ${prefix} rechts`,out);
  addPt(e5l,`5m Ecke ${prefix} links`,out);
  addLine(f5r,e5r,`5m Linie ${prefix} rechts`,out);
  addLine(f5l,e5l,`5m Linie ${prefix} links`,out);
  addLine(e5r,e5l,`5m Parallel ${prefix}`,out);

  // 16-m-Raum
  const f16r={x:tor_r.x+nx*16.5,y:tor_r.y+ny*16.5},
        f16l={x:tor_l.x-nx*16.5,y:tor_l.y-ny*16.5};
  const e16r={x:f16r.x+ux*16.5,y:f16r.y+uy*16.5},
        e16l={x:f16l.x+ux*16.5,y:f16l.y+uy*16.5};
  addPt(f16r,`16m Fusspunkt ${prefix} rechts`,out);
  addPt(f16l,`16m Fusspunkt ${prefix} links`,out);
  addPt(e16r,`Strafraum Ecke ${prefix} rechts`,out);
  addPt(e16l,`Strafraum Ecke ${prefix} links`,out);
  addLine(f16r,e16r,`16m Linie ${prefix} rechts`,out);
  addLine(f16l,e16l,`16m Linie ${prefix} links`,out);
  addLine(e16r,e16l,`16m Parallel ${prefix}`,out);

  const elfer={x:mitte.x+ux*11,y:mitte.y+uy*11};
  addPt(elfer,`Elfmeterpunkt ${prefix}`,out);
}

/* ---- Kleinfeld (Tor 5,00 m) ---- */
function drawKleinfeld(mitte,ux,uy,nx,ny,prefix,out){
  const off=2.5;
  const tor_r={x:mitte.x+nx*off,y:mitte.y+ny*off};
  const tor_l={x:mitte.x-nx*off,y:mitte.y-ny*off};
  addPt(mitte,`Kleinfeld Torlinienmittelpunkt ${prefix}`,out);
  addPt(tor_r,`Kleinfeld Torpfosten ${prefix} rechts`,out);
  addPt(tor_l,`Kleinfeld Torpfosten ${prefix} links`,out);
  addLine(tor_r,tor_l,`Kleinfeld Torlinie ${prefix}`,out);

  const f12r={x:tor_r.x+nx*12,y:tor_r.y+ny*12};
  const f12l={x:tor_l.x-nx*12,y:tor_l.y-ny*12};
  addPt(f12r,`12m Fusspunkt ${prefix} rechts`,out);
  addPt(f12l,`12m Fusspunkt ${prefix} links`,out);

  const ef_r={x:f12r.x+nx*10,y:f12r.y+ny*10};
  const ef_l={x:f12l.x-nx*10,y:f12l.y-ny*10};
  addPt(ef_r,`Kleinfeld Eckfahne ${prefix} rechts`,out);
  addPt(ef_l,`Kleinfeld Eckfahne ${prefix} links`,out);
  addLine(f12r,ef_r,`Kleinfeld Torlinie Verlängerung ${prefix} rechts`,out);
  addLine(f12l,ef_l,`Kleinfeld Torlinie Verlängerung ${prefix} links`,out);

  const e12r={x:f12r.x+ux*12,y:f12r.y+uy*12};
  const e12l={x:f12l.x+ux*12,y:f12l.y+uy*12};
  addPt(e12r,`Kleinfeld Strafraum Ecke ${prefix} rechts`,out);
  addPt(e12l,`Kleinfeld Strafraum Ecke ${prefix} links`,out);
  addLine(f12r,e12r,`Kleinfeld Strafraum Linie ${prefix} rechts`,out);
  addLine(f12l,e12l,`Kleinfeld Strafraum Linie ${prefix} links`,out);
  addLine(e12r,e12l,`Kleinfeld Strafraum Parallel ${prefix}`,out);

  const elfer={x:mitte.x+ux*9,y:mitte.y+uy*9};
  addPt(elfer,`Kleinfeld Elfmeterpunkt ${prefix}`,out);

  return { ef_r, ef_l };
}

/* ---- Klick-Logik: 2 Punkte = Start + Richtung ---- */
map.on('click',e=>{
  if(handles.getLayers().length===2) return;
  clicks.addLayer(L.circleMarker(e.latlng,{radius:5}));
  if(!p1){ p1=e.latlng; }
  else{
    p2=e.latlng; makeHandles();
    const P1=toUTM(p1.lat,p1.lng), P2=toUTM(p2.lat,p2.lng);
    const L=Math.hypot(P2.x-P1.x,P2.y-P1.y);
    lengthInput.value=String(Math.round(L)); // ganze Meter Default
    recompute(true);
  }
});
function makeHandles(){
  handles.clearLayers();
  const m1=L.marker(p1,{draggable:true,title:"Punkt 1 (Start, unten rechts)"}).addTo(handles);
  const m2=L.marker(p2,{draggable:true,title:"Punkt 2 (Richtung, oben rechts)"}).addTo(handles);
  m1.on('drag',()=>{p1=m1.getLatLng();recompute(true)});
  m2.on('drag',()=>{p2=m2.getLatLng();recompute(true)});
}

/* ---- Zeichnen ---- */
function recompute(){
  if(!p1||!p2) return;
  draw.clearLayers();

  const P1=toUTM(p1.lat,p1.lng), P2=toUTM(p2.lat,p2.lng);
  const {ux,uy}=norm(P2.x-P1.x,P2.y-P1.y);
  const len=Math.max(1,Math.round(parseFloat(lengthInput.value||"0")||0));
  const nx=-uy, ny=ux;
  const W=parseFloat(widthInput.value||"65");

  // Außenrechteck aus Start+Richtung+Maßen
  const UR={x:P1.x,y:P1.y};                         // unten rechts (Start)
  const OR={x:P1.x+ux*len,y:P1.y+uy*len};           // oben rechts
  const OL={x:OR.x+nx*W,y:OR.y+ny*W};
  const UL={x:UR.x+nx*W,y:UR.y+ny*W};

  const out={points:[],lines:[]};
  const mode=modeSel.value;

  // Außenlinien + Ecken
  addLine(UL,UR,"Grundlinie unten",out);
  addLine(UR,OR,"Seitenlinie rechts",out);
  addLine(OR,OL,"Grundlinie oben",out);
  addLine(OL,UL,"Seitenlinie links",out);
  addPt(UL,"Eckfahne unten links",out);
  addPt(UR,"Eckfahne unten rechts",out);
  addPt(OL,"Eckfahne oben links",out);
  addPt(OR,"Eckfahne oben rechts",out);

  // Mittellinie & Mittelkreis
  const mu=mid(UL,UR), mo=mid(OL,OR);
  const ml=mid(UL,OL), mr=mid(UR,OR);
  addLine(ml,mr,"Mittellinie",out);
  const an=mid(mu,mo); addPt(an,"Anstoßpunkt",out);
  addPoly(circle(an,9.15,96),"Mittelkreis",out);

  // ✚ Schnittpunkte Mittellinie ↔ Seitenlinien (Großfeld)
  const spR=lineIntersection(UR,OR,ml,mr);
  const spL=lineIntersection(UL,OL,ml,mr);
  if(spR) addPt(spR,"Schnittpunkt Mittellinie & Seitenlinie rechts",out);
  if(spL) addPt(spL,"Schnittpunkt Mittellinie & Seitenlinie links",out);

  // ✚ Schnittpunkte Mittelkreis ↔ Mittellinie
  const circleHits=circleLineIntersections(an,9.15,ml,mr);
  circleHits.forEach((p,i)=>addPt(p,`Schnittpunkt Mittelkreis & Mittellinie ${i===0?'(1)':'(2)'}`,out));

  // Großfeld-Torbereiche
  drawTorbereich(mu,ux,uy,nx,ny,"unten",out);
  drawTorbereich(mo,-ux,-uy,nx,ny,"oben",out);

  // Kleinfeld zusätzlich (falls gewählt)
  if(mode==='kleinfeld_im_grossfeld'){
    const k_unten={x:mu.x+ux*16.5,y:mu.y+uy*16.5};
    const k_oben ={x:mo.x-ux*16.5,y:mo.y-uy*16.5};
    const k1=drawKleinfeld(k_unten,ux,uy,nx,ny,"unten",out);
    const k2=drawKleinfeld(k_oben,-ux,-uy,nx,ny,"oben",out);

    // Verbindungslinien & ✚ Kleinfeld-Schnittpunkte mit Mittellinie
    addLine(k1.ef_r,k2.ef_r,"Kleinfeld Verbindung rechts",out);
    addLine(k1.ef_l,k2.ef_l,"Kleinfeld Verbindung links",out);
    const spKr=lineIntersection(k1.ef_r,k2.ef_r,ml,mr);
    const spKl=lineIntersection(k1.ef_l,k2.ef_l,ml,mr);
    if(spKr) addPt(spKr,"Schnittpunkt Kleinfeld-Verbindung & Mittellinie rechts",out);
    if(spKl) addPt(spKl,"Schnittpunkt Kleinfeld-Verbindung & Mittellinie links",out);
  }

  lastResult=out;
}

/* ---- Buttons ---- */
document.getElementById('reset').onclick=()=>{draw.clearLayers();handles.clearLayers();clicks.clearLayers();p1=p2=null;lastResult=null;lengthInput.value="";};
document.getElementById('geojson').onclick=exportBothGeoJSON;

/* ---- Export: Punkte & Linien getrennt, Dateiname frei wählbar ---- */
function exportBothGeoJSON(){
  if(!lastResult){alert("Kein Feld erzeugt.");return;}
  const pt=(x,y)=>{const g=toLL(x,y);return[g.lon,g.lat]};
  const base=(fnameInput.value||"X-Platz_SVU").trim().replace(/[\\/:*?"<>|]+/g,"_");
  const ts=new Date().toISOString().replace(/[:.]/g,"-");

  // Punkte
  const fcPts={type:"FeatureCollection",features:[]};
  for(const p of lastResult.points){
    fcPts.features.push({type:"Feature",properties:{name:p.name,type:"point"},geometry:{type:"Point",coordinates:pt(p.x,p.y)}});
  }
  // Linien
  const fcLines={type:"FeatureCollection",features:[]};
  for(const l of lastResult.lines){
    let coords=[];
    if(l.points && l.points.length>1){ coords=l.points.map(q=>pt(q.x,q.y)); }
    else if(l.p1 && l.p2){ coords=[pt(l.p1.x,l.p1.y), pt(l.p2.x,l.p2.y)]; }
    else { continue; }
    fcLines.features.push({
      type:"Feature",
      properties:{name:l.name,type:"line",length_m:Number(l.len?.toFixed?.(2)||l.len||0)},
      geometry:{type:"LineString",coordinates:coords}
    });
  }

  const save=(obj,filename)=>{
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:"application/geo+json"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=filename; a.click(); URL.revokeObjectURL(a.href);
  };
  save(fcPts,   `${base}_points_${ts}.geojson`);
  save(fcLines, `${base}_lines_${ts}.geojson`);
}
</script>
</body>
</html>